var gn=Object.defineProperty;var mn=(i,y,c)=>y in i?gn(i,y,{enumerable:!0,configurable:!0,writable:!0,value:c}):i[y]=c;var F=(i,y,c)=>(mn(i,typeof y!="symbol"?y+"":y,c),c),Le=(i,y,c)=>{if(!y.has(i))throw TypeError("Cannot "+c)};var r=(i,y,c)=>(Le(i,y,"read from private field"),c?c.call(i):y.get(i)),p=(i,y,c)=>{if(y.has(i))throw TypeError("Cannot add the same private member more than once");y instanceof WeakSet?y.add(i):y.set(i,c)},S=(i,y,c,X)=>(Le(i,y,"write to private field"),X?X.call(i,c):y.set(i,c),c),He=(i,y,c,X)=>({set _(je){S(i,y,je,c)},get _(){return r(i,y,X)}}),N=(i,y,c)=>(Le(i,y,"access private method"),c);(function(i,y){typeof exports=="object"&&typeof module<"u"?y(exports,require("isomorphic-ws"),require("zod")):typeof define=="function"&&define.amd?define(["exports","isomorphic-ws","zod"],y):(i=typeof globalThis<"u"?globalThis:i||self,y(i.Cirql={},i.WebSocket,i.Zod))})(this,function(i,y,c){var V,ye,Ue,be,Ye,Re,Ve,te,z,B,ne,re,Ne,Ze,C,ge,Qe,ie,Ce,W,v,T,me,ke,se,Te,$,b,oe,Oe,ue,Ae,ae,Z,ce;"use strict";class X extends Event{constructor(n,s){super("close");F(this,"code");F(this,"reason");this.code=n,this.reason=s}}class je extends Event{constructor(n){super("error");F(this,"error");this.error=n}}const Ke=e=>e.errors.map(n=>`- @${n.path.join(".")}: ${n.message}`).join(`
`);class I extends Error{constructor(n,s){super(n);F(this,"code");this.code=s}}class Pe extends I{constructor(n,s){super(n+`
`+Ke(s),"parse_failure");F(this,"reason");this.reason=s}}class q extends I{constructor(n,s){super(n,"invalid_query");F(this,"query");this.query=s}}class De extends I{constructor(n){super(`One or more queries returned a non-successful status code: 
${n.join(`
`)}`,"query_failure");F(this,"errors");this.errors=n}}class $e extends I{constructor(t){super(t,"auth_failure")}}const U=Symbol("Query Raw");function o(e){return{[U]:e}}function Xe(e){return o(`$${e}`)}function _e(e){return o(`type::bool(${a(e)})`)}function xe(e){return o(`type::datetime(${a(e)})`)}function et(e){return o(`type::decimal(${a(e)})`)}function tt(e){return o(`type::duration(${a(e)})`)}function nt(e){return o(`type::float(${a(e)})`)}function rt(e){return o(`type::int(${a(e)})`)}function it(e){return o(`type::number(${a(e)})`)}function st(e,t){return o(t?`type::point(${a(e)}, ${a(t)})`:`type::point(${a(e)})`)}function ot(e){return o(`type::regex(${a(e)})`)}function ut(e){return o(`type::string(${a(e)})`)}function at(e){return o(`type::table(${a(e)})`)}function ct(e,t){return o(`type::thing(${a(e)}, ${a(t)})`)}const ve={bool:_e,datetime:xe,decimal:et,duration:tt,float:nt,int:rt,number:it,point:st,regex:ot,string:ut,table:at,thing:ct},Je="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";function lt(e){let t="";for(let n=0;n<7;n++)t+=Je.charAt(Math.floor(Math.random()*Je.length));return e?`${t}_${e}`:t}function le(e,t){return`type::thing(${JSON.stringify(e)}, ${JSON.stringify(t)})`}function he(e){return e.fromTable?ve.thing(e.fromTable,e.fromId):o(a(e.fromId))}function fe(e){return e.toTable?ve.thing(e.toTable,e.toId):o(a(e.toId))}function pe(e){return typeof e=="object"&&e!==null&&!!e[U]}function ze(e){return typeof e=="object"&&e!==null&&"toQuery"in e}function de(...e){return e.some(t=>typeof t=="string"&&t.includes(","))}function a(e){if(e===void 0)throw new Error("Cannot use undefined value");return pe(e)?e[U]:ze(e)?`(${e.toQuery()})`:e instanceof Date?JSON.stringify(e.toISOString()):e===null?"NONE":JSON.stringify(e)}function Y(e,t){if(e===void 0)throw new Error("Cannot use undefined value");return pe(e)?t?`(${e[U]})`:e[U]:ze(e)?`(${e.toQuery()})`:e instanceof Date?e.toISOString():e===null?"NONE":e}function ht(e){const t=new URL("rpc",e.connection.endpoint.replace("http","ws")),n=setInterval(()=>l("ping"),3e4),s=new y(t),u=new Map;let h=!1;const l=(w,f=[])=>{const A=lt();return new Promise((M,j)=>{u.set(A,[M,j]),s.send(JSON.stringify({id:A,method:w,params:f})),setTimeout(()=>{u.delete(A)&&j(new Error("Request timed out"))},5e3)})},d=(w,f)=>{var A;clearInterval(n),(A=e.onDisconnect)==null||A.call(e,w,f)},E=()=>{h=!0,s.close(),d(-1,"connection terminated")},m=async(w,f)=>l("query",f?[w,f]:[w]),g=async w=>{try{return"token"in w?(await l("authenticate",[w.token]),w.token):await l("signin",[w])}catch(f){throw new $e("Authentication failed: "+(f.message||"unknown error"))}},R=async w=>{try{return await l("signup",[w])}catch(f){throw new $e("Registration failed: "+(f.message||"unknown error"))}},J=async()=>{try{await l("invalidate")}catch(w){throw new $e("Sign out failed: "+(w.message||"unknown error"))}};return s.addEventListener("open",async()=>{var A;const{namespace:w,database:f}=e.connection;e.credentials&&g(e.credentials),w&&f&&l("use",[w,f]),(A=e.onConnect)==null||A.call(e)}),s.addEventListener("close",w=>{h||d(w.code,w.reason)}),s.addEventListener("message",w=>{const{id:f,result:A,method:M,error:j}=JSON.parse(w.data);if(M!=="notify")if(!u.has(f))console.warn("No callback for message",w.data);else{const[H,K]=u.get(f);u.delete(f),j?K(j):H(A)}}),s.addEventListener("error",w=>{var f;(f=e.onError)==null||f.call(e,w.error)}),{close:E,query:m,signIn:g,signUp:R,signOut:J}}class Be extends EventTarget{constructor(n){super();p(this,ye);p(this,be);p(this,Re);p(this,V,void 0);S(this,V,n)}async execute(n){return(await this.batch(n))[0]}async batch(...n){return N(this,ye,Ue).call(this,{queries:n,prefix:"",suffix:""})}async transaction(...n){return N(this,ye,Ue).call(this,{queries:n,prefix:"BEGIN TRANSACTION",suffix:"COMMIT TRANSACTION"})}}V=new WeakMap,ye=new WeakSet,Ue=async function(n){var E;if(!r(this,V).onRequest())throw new I("There is no active connection to the database","no_connection");if(n.queries.length===0)return[];const s=N(this,Re,Ve).call(this,n),u=N(this,be,Ye).call(this,n),h=[],l=[];r(this,V).onLog(u,s);const d=await r(this,V).onQuery(u,s);if(!Array.isArray(d)||d.length!==n.queries.length)throw new I("The response from the database was invalid","invalid_response");for(let m=0;m<d.length;m++){const{status:g,detail:R}=d[m];g!=="OK"&&h.push(`- Query ${m+1}: ${R}`)}if(h.length>0)throw new De(h);for(let m=0;m<d.length;m++){const{result:g}=d[m],{query:R,schema:J,validate:w}=n.queries[m],f=R._quantity;if(f=="zero"){l.push(void 0);continue}const A=((E=R._transform)==null?void 0:E.call(R,g))??g,M=Array.isArray(A)?A:[A];let j;if(w===!1)j=M;else{const H=R._schema||J;if(!H)throw new I(`No schema provided for query ${m+1}`,"invalid_request");const K=H.array().safeParse(M);if(!K.success)throw new Pe(`Query ${m+1} failed to parse`,K.error);j=K.data}if(f=="one"&&j.length===0){if(R._fallback===void 0)throw new I(`Query ${m+1} expected at least one result but got ${j.length}`,"invalid_response");l.push(R._fallback);continue}if(f=="one"||f=="maybe"){if(j.length>1)throw new I(`Query ${m+1} expected at most one result but got ${j.length}`,"invalid_response");l.push(j[0]||null);continue}l.push(j)}return l},be=new WeakSet,Ye=function(n){let s=n.queries.map(u=>u.query.toQuery());return n.prefix&&(s=[n.prefix,...s]),n.suffix&&(s=[...s,n.suffix]),s.join(`;
`)},Re=new WeakSet,Ve=function(n){const s={};for(const u of n.queries)for(const[h,l]of Object.entries(u.params||{})){if(h in s)throw new I(`The parameter "${h}" was defined multiple times`,"invalid_query");s[h]=l}return s};class ft extends Be{constructor(n){super({onQuery:(s,u)=>this.handle.query(s,u),onRequest:()=>this.isConnected&&!!this.handle,onLog:(s,u)=>{this.options.logging&&this.options.logPrinter(s,u)}});F(this,"options");p(this,te,null);p(this,z,!1);p(this,B,!1);p(this,ne,0);p(this,re,void 0);this.options={autoConnect:!0,logging:!1,logPrinter:s=>console.log(s),retryCount:10,retryDelay:2e3,...n},n.autoConnect!==!1&&this.connect()}get isConnected(){return r(this,B)&&!r(this,z)}get handle(){return r(this,te)}connect(){r(this,B)||r(this,z)||(this.dispatchEvent(new Event("connect")),S(this,z,!0),S(this,te,ht({connection:this.options.connection,credentials:this.options.credentials,onConnect:()=>{clearTimeout(r(this,re)),S(this,ne,0),S(this,re,void 0),S(this,B,!0),S(this,z,!1),this.dispatchEvent(new Event("open"))},onDisconnect:(n,s)=>{S(this,B,!1),S(this,z,!1),this.dispatchEvent(new X(n,s));const{retryCount:u,retryDelay:h}=this.options;(u<0||u>0&&r(this,ne)<u)&&(He(this,ne)._++,S(this,re,setTimeout(()=>this.connect(),h)))},onError:n=>{this.dispatchEvent(new je(n))}})))}disconnect(){var n;r(this,B)&&((n=r(this,te))==null||n.close())}ready(){return this.isConnected?Promise.resolve():new Promise((n,s)=>{this.addEventListener("open",()=>n(),{once:!0}),this.addEventListener("error",u=>s(u),{once:!0})})}signIn(n){return this.handle.signIn(n)}signUp(n){return this.handle.signUp(n)}signOut(){return this.handle.signOut()}}te=new WeakMap,z=new WeakMap,B=new WeakMap,ne=new WeakMap,re=new WeakMap;class dt extends Be{constructor(n){super({onQuery:(s,u)=>N(this,Ne,Ze).call(this,s,u),onRequest:()=>!0,onLog:(s,u)=>{this.options.logging&&this.options.logPrinter(s,u)}});p(this,Ne);F(this,"options");this.options={logging:!1,logPrinter:s=>console.log(s),...n}}signIn(n){throw new Error("Stateless queries do not support authentication yet")}signUp(n){throw new Error("Stateless queries do not support authentication yet")}signOut(){throw new Error("Stateless queries do not support authentication yet")}}Ne=new WeakSet,Ze=async function(n,s){const{endpoint:u,namespace:h,database:l}=this.options.connection,{user:d,pass:E,DB:m,NS:g,SC:R,token:J}=this.options.credentials,w=new URLSearchParams,f=new URL("sql",u);if(!d&&!E&&!J)throw new I("Missing username & password or token","invalid_request");const M={"User-Agent":"Cirql",Authorization:J?`Bearer ${J}`:`Basic ${btoa(`${d}:${E}`)}`,Accept:"application/json"};return(g||h)&&(M.NS=g||h),(m||l)&&(M.DB=m||l),R&&(M.SC=R),Object.entries(s).forEach(([H,K])=>{w.set(H,K)}),await fetch(`${f}?${w}`,{method:"POST",headers:M,body:n}).then(H=>H.json())};function Fe(e){const t=[];function n(s,u){Object.entries(s).forEach(([h,l])=>{if(l!==void 0)if(pe(l)){const d=l[U];d?t.push(`${u}${h} ${d}`):n(l,`${u}${h}.`)}else t.push(`${u}${h} = ${l===null?"NONE":JSON.stringify(l)}`)})}return n(e,""),t.join(", ")}function P(e){const t=Object.keys(e),n=[];for(const s of t)if(s==="OR"||s==="AND"){const u=e[s],h=[];if(u===void 0)throw new I("Received expected undefined property in where clause","invalid_request");for(const l of u){const d=P(l);d&&h.push(`(${d})`)}if(h.length==0)continue;n.push(`(${h.join(` ${s} `)})`)}else if(s=="QUERY"){const[u,h]=e[s];n.push(`(${u.toQuery()}) ${h[U]}`)}else{const u=e[s];pe(u)?n.push(`${s} ${u[U]}`):n.push(`${s} = ${JSON.stringify(u)}`)}return n.join(" AND ")}const Q=class{constructor(t){p(this,ge);p(this,ie);p(this,C,void 0);S(this,C,t)}get _schema(){return r(this,C).schema}get _quantity(){return r(this,C).quantity}get _state(){return Object.freeze({...r(this,C)})}with(t){return new Q({...r(this,C),schema:t})}withSchema(t){return this.with(c.z.object(t))}withAny(){return this.with(c.z.any())}set(t,n){if(N(this,ie,Ce).call(this))throw new q("Cannot set field when content is set");return new Q({...r(this,C),setFields:{...r(this,C).setFields,[t]:n}})}setAll(t){if(N(this,ie,Ce).call(this))throw new q("Cannot set fields when content is set");return new Q({...r(this,C),setFields:{...r(this,C).setFields,...t}})}content(t){if(N(this,ge,Qe).call(this))throw new q("Cannot set content when fields are set");return new Q({...r(this,C),content:t})}return(t){return new Q({...r(this,C),returnMode:t})}returnFields(...t){return new Q({...r(this,C),returnMode:"fields",returnFields:t})}timeout(t){return new Q({...r(this,C),timeout:t})}parallel(){return new Q({...r(this,C),parallel:!0})}toQuery(){const{targets:t,content:n,setFields:s,returnMode:u,returnFields:h,timeout:l,parallel:d}=r(this,C);if(!t)throw new Error("No targets specified");let E=`CREATE ${t}`;if(N(this,ge,Qe).call(this)){const m=Fe(s);m&&(E+=` SET ${m}`)}else N(this,ie,Ce).call(this)&&(E+=` CONTENT ${JSON.stringify(n)}`);return u==="fields"?E+=` RETURN ${h.join(", ")}`:u&&(E+=` RETURN ${u.toUpperCase()}`),l&&(E+=` TIMEOUT ${l}s`),d&&(E+=" PARALLEL"),E}};let we=Q;C=new WeakMap,ge=new WeakSet,Qe=function(){return Object.keys(r(this,C).setFields).length>0},ie=new WeakSet,Ce=function(){return Object.keys(r(this,C).content).length>0};function wt(...e){if(e.length===0)throw new q("At least one target must be specified");if(de(...e))throw new q("Multiple targets must be specified seperately");return new we({schema:null,quantity:e.length===1?"one":"many",targets:e.map(t=>Y(t)).join(", "),setFields:{},content:{},returnMode:void 0,returnFields:[],timeout:void 0,parallel:!1})}function yt(e,t){return new we({schema:null,quantity:"one",targets:le(e,t),setFields:{},content:{},returnMode:void 0,returnFields:[],timeout:void 0,parallel:!1})}function D(e){return o(`= ${a(e)}`)}function gt(e){return o(`!= ${a(e)}`)}function mt(e){return o(`== ${a(e)}`)}function $t(e){return o(`?= ${a(e)}`)}function pt(e){return o(`*= ${a(e)}`)}function Et(e){return o(`~ ${a(e)}`)}function qt(e){return o(`!~ ${a(e)}`)}function bt(e){return o(`?~ ${a(e)}`)}function Rt(e){return o(`*~ ${a(e)}`)}function Nt(e){return o(`< ${a(e)}`)}function St(e){return o(`<= ${a(e)}`)}function Ct(e){return o(`> ${a(e)}`)}function Tt(e){return o(`>= ${a(e)}`)}function Ot(e){return o(`CONTAINS ${a(e)}`)}function At(e){return o(`CONTAINSNOT ${a(e)}`)}function jt(e){return o(`CONTAINSALL ${a(e)}`)}function vt(e){return o(`CONTAINSANY ${a(e)}`)}function Ft(e){return o(`CONTAINSNONE ${a(e)}`)}function It(e){return o(`INSIDE ${a(e)}`)}function Mt(e){return o(`NOTINSIDE ${a(e)}`)}function Lt(e){return o(`ALLINSIDE ${a(e)}`)}function Ut(e){return o(`ANYINSIDE ${a(e)}`)}function Qt(e){return o(`NONEINSIDE ${a(e)}`)}function kt(e){return o(`OUTSIDE ${a(e)}`)}function Pt(e){return o(`INTERSECTS ${a(e)}`)}function Dt(e){return o(`+= ${a(e)}`)}function Jt(e){return o(`-= ${a(e)}`)}const Me=class{constructor(t){p(this,W,void 0);F(this,"_fallback",0);F(this,"_schema",c.z.number());F(this,"_quantity","one");S(this,W,t)}get _state(){return Object.freeze({...r(this,W)})}where(t){if(r(this,W).relation)throw new q("Cannot use where clause with countRelation");return typeof t=="object"&&(t=P(t)),new Me({...r(this,W),where:t})}toQuery(){const{target:t,where:n}=r(this,W);if(!t)throw new Error("No target specified");let s=`SELECT count() FROM ${t}`;return n&&(s+=` WHERE ${n}`),s+=" GROUP ALL",s}_transform(t){return t.map(n=>n.count)}};let _=Me;W=new WeakMap;function zt(e){return new _({target:Y(e),where:void 0,relation:!1})}function Bt(e,t){return new _({target:t===void 0?JSON.stringify(e):le(e,t),where:void 0,relation:!1})}function Wt(e){return new _({target:e.edge,where:P({in:D(he(e)),out:D(fe(e))}),relation:!0})}const G=class{constructor(t){p(this,v,void 0);S(this,v,t)}get _schema(){return r(this,v).schema}get _quantity(){return r(this,v).quantity}get _state(){return Object.freeze({...r(this,v)})}with(t){return new G({...r(this,v),schema:t})}withSchema(t){return this.with(c.z.object(t))}withAny(){return this.with(c.z.any())}where(t){if(r(this,v).unrelate)throw new q("Cannot use where clause with delRelation");return typeof t=="object"&&(t=P(t)),new G({...r(this,v),where:t})}return(t){return new G({...r(this,v),returnMode:t})}returnFields(...t){return new G({...r(this,v),returnMode:"fields",returnFields:t})}timeout(t){return new G({...r(this,v),timeout:t})}parallel(){return new G({...r(this,v),parallel:!0})}toQuery(){const{targets:t,where:n,returnMode:s,returnFields:u,timeout:h,parallel:l}=r(this,v);if(!t)throw new Error("No targets specified");let d=`DELETE ${t}`;return n&&(d+=` WHERE ${n}`),s==="fields"?d+=` RETURN ${u.join(", ")}`:s&&(d+=` RETURN ${s.toUpperCase()}`),h&&(d+=` TIMEOUT ${h}s`),l&&(d+=" PARALLEL"),d}};let x=G;v=new WeakMap;function Gt(...e){if(e.length===0)throw new q("At least one target must be specified");if(de(...e))throw new q("Multiple targets must be specified seperately");return new x({schema:null,quantity:"many",targets:e.map(t=>Y(t)).join(", "),where:void 0,returnMode:"before",returnFields:[],timeout:void 0,parallel:!1,unrelate:!1})}function Ht(e,t){return new x({schema:null,quantity:"maybe",targets:t===void 0?JSON.stringify(e):le(e,t),where:void 0,returnMode:"before",returnFields:[],timeout:void 0,parallel:!1,unrelate:!1})}function Yt(e){return new x({schema:null,quantity:"maybe",targets:e.edge,where:P({in:D(he(e)),out:D(fe(e))}),returnMode:"before",returnFields:[],timeout:void 0,parallel:!1,unrelate:!0})}const k=class{constructor(t){p(this,me);p(this,se);p(this,T,void 0);F(this,"_quantity","one");S(this,T,t)}get _schema(){return r(this,T).schema}get _state(){return Object.freeze({...r(this,T)})}with(t){return new k({...r(this,T),schema:t})}withSchema(t){return this.with(c.z.object(t))}withAny(){return this.with(c.z.any())}set(t,n){if(N(this,se,Te).call(this))throw new q("Cannot set field when content is set");return new k({...r(this,T),setFields:{...r(this,T).setFields,[t]:n}})}setAll(t){if(N(this,se,Te).call(this))throw new q("Cannot set fields when content is set");return new k({...r(this,T),setFields:{...r(this,T).setFields,...t}})}content(t){if(N(this,me,ke).call(this))throw new q("Cannot set content when fields are set");return new k({...r(this,T),content:t})}return(t){return new k({...r(this,T),returnMode:t})}returnFields(...t){return new k({...r(this,T),returnMode:"fields",returnFields:t})}timeout(t){return new k({...r(this,T),timeout:t})}parallel(){return new k({...r(this,T),parallel:!0})}toQuery(){const{from:t,edge:n,to:s,content:u,setFields:h,returnMode:l,returnFields:d,timeout:E,parallel:m}=r(this,T);if(!t||!n||!s)throw new Error("From, edge, and to must be defined");let g=`RELATE ${t}->${n}->${s}`;if(N(this,me,ke).call(this)){const R=Fe(h);R&&(g+=` SET ${R}`)}else N(this,se,Te).call(this)&&(g+=` CONTENT ${JSON.stringify(u)}`);return l==="fields"?g+=` RETURN ${d.join(", ")}`:l&&(g+=` RETURN ${l.toUpperCase()}`),E&&(g+=` TIMEOUT ${E}s`),m&&(g+=" PARALLEL"),g}};let Ee=k;T=new WeakMap,me=new WeakSet,ke=function(){return Object.keys(r(this,T).setFields).length>0},se=new WeakSet,Te=function(){return Object.keys(r(this,T).content).length>0};function We(e,t,n){return new Ee({schema:null,from:Y(e,!0),edge:t,to:Y(n,!0),setFields:{},content:{},returnMode:void 0,returnFields:[],timeout:void 0,parallel:!1})}function Vt(e){const t=he(e),n=fe(e);return We(`(${t[U]})`,e.edge,`(${n[U]})`)}const O=class{constructor(t){p(this,$,void 0);S(this,$,t)}get _schema(){return r(this,$).schema}get _quantity(){return r(this,$).quantity}get _state(){return Object.freeze({...r(this,$)})}with(t){return new O({...r(this,$),schema:t})}withSchema(t){return this.with(c.z.object(t))}withAny(){return this.with(c.z.any())}and(t){return new O({...r(this,$),projections:[...r(this,$).projections,t]})}andQuery(t,n){return this.and(`(${n.toQuery()}) AS ${t}`)}from(...t){const n=t.map(s=>{if(typeof s=="string"&&de(s))throw new q("Multiple targets must be specified seperately");return Y(s)});return new O({...r(this,$),targets:n.join(", ")})}fromRecord(t,n){return new O({...r(this,$),quantity:"maybe",targets:n===void 0?JSON.stringify(t):le(t,n),limit:1})}fromRelation(t){return new O({...r(this,$),quantity:"maybe",relation:!0,targets:t.edge,where:P({in:D(he(t)),out:D(fe(t))})})}where(t){if(r(this,$).relation)throw new q("Cannot use where clause with fromRelation");return typeof t=="object"&&(t=P(t)),new O({...r(this,$),where:t})}split(...t){return new O({...r(this,$),split:t})}groupBy(...t){return new O({...r(this,$),group:t})}groupAll(){return new O({...r(this,$),group:"all"})}orderBy(t,n){const s=typeof t=="string"?{[t]:n||"asc"}:t;return new O({...r(this,$),order:s})}limit(t){return new O({...r(this,$),quantity:"many",limit:t})}one(){return new O({...r(this,$),quantity:"maybe",limit:1})}start(t){return new O({...r(this,$),start:t})}fetch(...t){return new O({...r(this,$),fetch:t})}timeout(t){return new O({...r(this,$),timeout:t})}parallel(){return new O({...r(this,$),parallel:!0})}toQuery(){const{projections:t,targets:n,where:s,split:u,group:h,order:l,limit:d,start:E,fetch:m,timeout:g,parallel:R}=r(this,$);if(t){if(!n)throw new Error("No targets specified")}else throw new Error("No projections specified");const J=t.length>0?t.join(", "):"*",w=Object.entries(l);let f=`SELECT ${J} FROM ${n}`;if(s&&(f+=` WHERE ${s}`),u.length>0&&(f+=` SPLIT ${u.join(", ")}`),h==="all"?f+=" GROUP ALL":h.length>0&&(f+=` GROUP BY ${h.join(", ")}`),w.length>0){const A=w.map(([M,j])=>`${M} ${j.toUpperCase()}`);f+=` ORDER BY ${A.join(", ")}`}return d&&(f+=` LIMIT BY ${d}`),E&&(f+=` START AT ${E}`),m.length>0&&(f+=` FETCH ${m.join(", ")}`),g&&(f+=` TIMEOUT ${g}s`),R&&(f+=" PARALLEL"),f}};let qe=O;$=new WeakMap;function Zt(...e){if(de(...e))throw new q("Multiple projections must be specified seperately");return new qe({schema:null,quantity:"many",projections:e,targets:void 0,where:void 0,split:[],group:[],order:{},limit:void 0,start:void 0,fetch:[],timeout:void 0,parallel:!1,relation:!1})}const L=class{constructor(t){p(this,oe);p(this,ue);p(this,b,void 0);S(this,b,t)}get _schema(){return r(this,b).schema}get _quantity(){return r(this,b).quantity}get _state(){return Object.freeze({...r(this,b)})}with(t){return new L({...r(this,b),schema:t})}withSchema(t){return this.with(c.z.object(t))}withAny(){return this.with(c.z.any())}set(t,n){if(N(this,ue,Ae).call(this))throw new q("Cannot set field when content is set");return new L({...r(this,b),setFields:{...r(this,b).setFields,[t]:n}})}setAll(t){if(N(this,ue,Ae).call(this))throw new q("Cannot set fields when content is set");return new L({...r(this,b),setFields:{...r(this,b).setFields,...t}})}content(t){if(N(this,oe,Oe).call(this))throw new q("Cannot set content when fields are set");return new L({...r(this,b),content:t,contentMode:"replace"})}merge(t){if(N(this,oe,Oe).call(this))throw new q("Cannot set content when fields are set");return new L({...r(this,b),content:t,contentMode:"merge"})}where(t){if(r(this,b).relation)throw new q("Cannot use where clause with updateRelation");return typeof t=="object"&&(t=P(t)),new L({...r(this,b),where:t})}return(t){return new L({...r(this,b),returnMode:t})}returnFields(...t){return new L({...r(this,b),returnMode:"fields",returnFields:t})}timeout(t){return new L({...r(this,b),timeout:t})}parallel(){return new L({...r(this,b),parallel:!0})}toQuery(){const{targets:t,content:n,contentMode:s,setFields:u,where:h,returnMode:l,returnFields:d,timeout:E,parallel:m}=r(this,b);if(!t)throw new Error("No targets specified");let g=`UPDATE ${t}`;if(N(this,oe,Oe).call(this)){const R=Fe(u);R&&(g+=` SET ${R}`)}else N(this,ue,Ae).call(this)&&(g+=` ${s==="merge"?"MERGE":"CONTENT"} ${JSON.stringify(n)}`);return h&&(g+=` WHERE ${h}`),l==="fields"?g+=` RETURN ${d.join(", ")}`:l&&(g+=` RETURN ${l.toUpperCase()}`),E&&(g+=` TIMEOUT ${E}s`),m&&(g+=" PARALLEL"),g}};let ee=L;b=new WeakMap,oe=new WeakSet,Oe=function(){return Object.keys(r(this,b).setFields).length>0},ue=new WeakSet,Ae=function(){return Object.keys(r(this,b).content).length>0};function Kt(...e){if(e.length===0)throw new q("At least one target must be specified");if(de(...e))throw new q("Multiple targets must be specified seperately");return new ee({schema:null,quantity:"many",targets:e.map(t=>Y(t)).join(", "),setFields:{},content:{},contentMode:void 0,where:void 0,returnMode:void 0,returnFields:[],timeout:void 0,parallel:!1,relation:!1})}function Xt(e,t){return new ee({schema:null,quantity:"maybe",targets:t===void 0?JSON.stringify(e):le(e,t),setFields:{},content:{},contentMode:void 0,where:void 0,returnMode:void 0,returnFields:[],timeout:void 0,parallel:!1,relation:!1})}function _t(e){return new ee({schema:null,quantity:"maybe",targets:e.edge,where:P({in:D(he(e)),out:D(fe(e))}),setFields:{},content:{},contentMode:void 0,returnMode:void 0,returnFields:[],timeout:void 0,parallel:!1,relation:!0})}const Se=class{constructor(t,n,s){p(this,ae,void 0);p(this,Z,void 0);p(this,ce,void 0);S(this,ae,t),S(this,Z,n),S(this,ce,s)}get _quantity(){return r(this,ce)}get _schema(){return r(this,ae)}with(t){return new Se(t,r(this,Z),r(this,ce))}withSchema(t){return this.with(c.z.object(t))}withAny(){return this.with(c.z.any())}single(){return new Se(r(this,ae),r(this,Z),"maybe")}toQuery(){return r(this,Z)}};let Ie=Se;ae=new WeakMap,Z=new WeakMap,ce=new WeakMap;function Ge(e){return new Ie(null,e,"many")}const xt=/^[a-zA-Z0-9_]*$/;function en(e,t){if(!xt.test(e))throw new Error(`Invalid LET name: ${e}`);return{_quantity:"zero",_schema:c.z.undefined(),toQuery(){return`LET $${e} = ${a(t)}`}}}const tn=c.z.object({id:c.z.string()}),nn=c.z.object({id:c.z.string(),in:c.z.string(),out:c.z.string()});function rn(e){return e.trim().split(";").filter(t=>!!t).map(t=>({query:Ge(t),schema:c.z.any()}))}function sn(){return o("time::now()")}const on={now:sn};function un(){return o("rand::bool()")}function an(e){return o(`rand::enum(${e.map(a).join(", ")})`)}function cn(e=0,t=1){return o(`rand::float(${e}, ${t})`)}function ln(e){return o(`rand::guid(${e??""})`)}function hn(e,t){return o(e&&t?`rand::int(${e}, ${t})`:"rand::int()")}function fn(e){return o(`rand::string(${e??""})`)}function dn(e,t){return o(e&&t?`rand::time(${e}, ${t})`:"rand::time()")}function wn(){return o("rand::uuid()")}const yn={bool:un,enumOf:an,float:cn,guid:ln,int:hn,string:fn,time:dn,uuid:wn};i.Cirql=ft,i.CirqlAuthenticationError=$e,i.CirqlError=I,i.CirqlParseError=Pe,i.CirqlQueryError=De,i.CirqlStateless=dt,i.CirqlWriterError=q,i.CountQueryWriter=_,i.CreateQueryWriter=we,i.DeleteQueryWriter=x,i.EdgeSchema=nn,i.RecordSchema=tn,i.RelateQueryWriter=Ee,i.SelectQueryWriter=qe,i.UpdateQueryWriter=ee,i.add=Dt,i.all=pt,i.allInside=Lt,i.any=$t,i.anyInside=Ut,i.contains=Ot,i.containsAll=jt,i.containsAny=vt,i.containsNone=Ft,i.containsNot=At,i.count=zt,i.countRecord=Bt,i.countRelation=Wt,i.create=wt,i.createRecord=yt,i.del=Gt,i.delRecord=Ht,i.delRelation=Yt,i.eeq=mt,i.eq=D,i.fall=Rt,i.fany=bt,i.feq=Et,i.gt=Ct,i.gte=Tt,i.inside=It,i.intersects=Pt,i.letValue=en,i.lt=Nt,i.lte=St,i.neq=gt,i.nfeq=qt,i.noneInside=Qt,i.notInside=Mt,i.outside=kt,i.param=Xe,i.parseQueries=rn,i.query=Ge,i.rand=yn,i.raw=o,i.relate=We,i.relateRelation=Vt,i.remove=Jt,i.select=Zt,i.time=on,i.type=ve,i.update=Kt,i.updateRecord=Xt,i.updateRelation=_t,Object.defineProperty(i,Symbol.toStringTag,{value:"Module"})});
